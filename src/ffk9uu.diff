diff -r --new-file exp6-copy/build/boot_s.d exp6/build/boot_s.d
0a1,2
> build/boot_s.o: src/boot.S include/arm/mmu.h include/arm/sysregs.h \
>  include/mm.h include/peripherals/base.h include/peripherals/base.h
Binary files exp6-copy/build/boot_s.o and exp6/build/boot_s.o differ
diff -r --new-file exp6-copy/build/entry_s.d exp6/build/entry_s.d
0a1,2
> build/entry_s.o: src/entry.S include/arm/sysregs.h include/entry.h \
>  include/sys.h
Binary files exp6-copy/build/entry_s.o and exp6/build/entry_s.o differ
diff -r --new-file exp6-copy/build/fork_c.d exp6/build/fork_c.d
0a1,3
> build/fork_c.o: src/fork.c include/mm.h include/peripherals/base.h \
>  include/sched.h include/sched.h include/fork.h include/utils.h \
>  include/entry.h
Binary files exp6-copy/build/fork_c.o and exp6/build/fork_c.o differ
diff -r --new-file exp6-copy/build/irq_c.d exp6/build/irq_c.d
0a1,3
> build/irq_c.o: src/irq.c include/utils.h include/printf.h include/timer.h \
>  include/entry.h include/peripherals/irq.h include/peripherals/base.h \
>  include/mm.h include/peripherals/base.h include/sched.h
Binary files exp6-copy/build/irq_c.o and exp6/build/irq_c.o differ
diff -r --new-file exp6-copy/build/irq_s.d exp6/build/irq_s.d
0a1
> build/irq_s.o: src/irq.S
Binary files exp6-copy/build/irq_s.o and exp6/build/irq_s.o differ
Binary files exp6-copy/build/kernel8.elf and exp6/build/kernel8.elf differ
diff -r --new-file exp6-copy/build/kernel_c.d exp6/build/kernel_c.d
0a1,3
> build/kernel_c.o: src/kernel.c include/printf.h include/utils.h \
>  include/timer.h include/irq.h include/fork.h include/sched.h \
>  include/sched.h include/mini_uart.h include/sys.h include/user.h
Binary files exp6-copy/build/kernel_c.o and exp6/build/kernel_c.o differ
diff -r --new-file exp6-copy/build/mini_uart_c.d exp6/build/mini_uart_c.d
0a1,3
> build/mini_uart_c.o: src/mini_uart.c include/utils.h \
>  include/peripherals/mini_uart.h include/peripherals/base.h include/mm.h \
>  include/peripherals/base.h include/sched.h include/peripherals/gpio.h
Binary files exp6-copy/build/mini_uart_c.o and exp6/build/mini_uart_c.o differ
diff -r --new-file exp6-copy/build/mm_c.d exp6/build/mm_c.d
0a1,2
> build/mm_c.o: src/mm.c include/mm.h include/peripherals/base.h \
>  include/sched.h include/arm/mmu.h
Binary files exp6-copy/build/mm_c.o and exp6/build/mm_c.o differ
diff -r --new-file exp6-copy/build/mm_s.d exp6/build/mm_s.d
0a1
> build/mm_s.o: src/mm.S
Binary files exp6-copy/build/mm_s.o and exp6/build/mm_s.o differ
diff -r --new-file exp6-copy/build/printf_c.d exp6/build/printf_c.d
0a1
> build/printf_c.o: src/printf.c include/printf.h
Binary files exp6-copy/build/printf_c.o and exp6/build/printf_c.o differ
diff -r --new-file exp6-copy/build/sched_c.d exp6/build/sched_c.d
0a1,3
> build/sched_c.o: src/sched.c include/sched.h include/irq.h \
>  include/printf.h include/utils.h include/mm.h include/peripherals/base.h \
>  include/sched.h
Binary files exp6-copy/build/sched_c.o and exp6/build/sched_c.o differ
diff -r --new-file exp6-copy/build/sched_s.d exp6/build/sched_s.d
0a1
> build/sched_s.o: src/sched.S include/sched.h
Binary files exp6-copy/build/sched_s.o and exp6/build/sched_s.o differ
diff -r --new-file exp6-copy/build/sys_c.d exp6/build/sys_c.d
0a1,2
> build/sys_c.o: src/sys.c include/fork.h include/sched.h include/printf.h \
>  include/utils.h include/sched.h include/mm.h include/peripherals/base.h
Binary files exp6-copy/build/sys_c.o and exp6/build/sys_c.o differ
diff -r --new-file exp6-copy/build/timer_c.d exp6/build/timer_c.d
0a1,4
> build/timer_c.o: src/timer.c include/utils.h include/printf.h \
>  include/sched.h include/peripherals/timer.h include/peripherals/base.h \
>  include/mm.h include/peripherals/base.h include/sched.h \
>  include/peripherals/irq.h include/timer.h
Binary files exp6-copy/build/timer_c.o and exp6/build/timer_c.o differ
diff -r --new-file exp6-copy/build/timer_s.d exp6/build/timer_s.d
0a1
> build/timer_s.o: src/timer.S
Binary files exp6-copy/build/timer_s.o and exp6/build/timer_s.o differ
diff -r --new-file exp6-copy/build/user_c.d exp6/build/user_c.d
0a1,2
> build/user_c.o: src/user.c include/user_sys.h include/user.h \
>  include/printf.h
Binary files exp6-copy/build/user_c.o and exp6/build/user_c.o differ
diff -r --new-file exp6-copy/build/user_sys_s.d exp6/build/user_sys_s.d
0a1
> build/user_sys_s.o: src/user_sys.S
Binary files exp6-copy/build/user_sys_s.o and exp6/build/user_sys_s.o differ
diff -r --new-file exp6-copy/build/utils_s.d exp6/build/utils_s.d
0a1
> build/utils_s.o: src/utils.S
Binary files exp6-copy/build/utils_s.o and exp6/build/utils_s.o differ
Binary files exp6-copy/.DS_Store and exp6/.DS_Store differ
diff -r --new-file exp6-copy/.gdb_history exp6/.gdb_history
0a1,2
> b kernel.c:36
> c
diff -r --new-file exp6-copy/include/mm.h exp6/include/mm.h
32c32
< #define PG_DIR_SIZE			(3 * PAGE_SIZE)  
---
> #define PG_DIR_SIZE			(4 * PAGE_SIZE)  
diff -r --new-file exp6-copy/include/peripherals/irq.h exp6/include/peripherals/irq.h
4a5
> #include "mm.h"
25c26
< #define TIMER_INT_CTRL_0    (0x40000040)
---
> #define TIMER_INT_CTRL_0    (VA_START+0x40000040)
diff -r --new-file exp6-copy/include/timer.h exp6/include/timer.h
4,5c4,5
< void timer_init ( void );
< void handle_timer_irq ( void );
---
> // void timer_init ( void );
> // void handle_timer_irq ( void );
8c8
< void handle_generic_timer_irq ( void );
---
> void handle_timer_irq ( void );
Binary files exp6-copy/kernel8.img and exp6/kernel8.img differ
diff -r --new-file exp6-copy/src/boot.S exp6/src/boot.S
117a118
> 
137a139,166
> 
> 
> 
> 	// Allocating a new page table (either PGD or PUD) for the kernel's initial page tables
> 	// All the initial page tables are located in one continuous memory region
> 	//
> 	// @tbl: a register pointing to the last pgtable in a memory region, from which pgtables 
> 	//			are allocated sequentially
> 	// @virt: the virtual address that we are currently mapping
> 	// @shift: 39 in case of PGD and 30 in case of PUD
> 	// 		   apply to the virtual address in order to extract current table index. 
> 	// @tmp1/2: temporary registers to use; contents will be clobbered 
> 
> 	.macro	create_table_entry1, tbl, virt, shift, tmp1, tmp2
> 	// sub \tbl, \tbl, #PAGE_SIZE
> 	lsr	\tmp1, \virt, #\shift
> 	and	\tmp1, \tmp1, #PTRS_PER_TABLE-1		// tmp1: table index
> 
> 	add	\tmp2, \tbl, #PAGE_SIZE					// tmp2: addr of a next level pgtable PMD)
> 	add	\tmp2, \tmp2, #PAGE_SIZE				// tmp2: addr of second PMD. 
> 
> 	orr	\tmp2, \tmp2, #MM_TYPE_PAGE_TABLE		// tmp2: make a table descriptor. set bits[0:1] to 1. 
> 	str	\tmp2, [\tbl, \tmp1, lsl #3]			// store descriptor (tmp2) to the current pgtable at index (tmp1)
> 
> 	add	\tbl, \tbl, #PAGE_SIZE					
> 	add \tbl, \tbl, #PAGE_SIZE					// point @tbl to the newly create next level pgtable. programming ease
> 	.endm
> 
170a200
> 
182c212
< 
---
> 	// str   x30, [sp, #16*16]
192a223,224
> 
> 
201c233
< 	ldr 	x2, =(VA_START + DEVICE_BASE)				// x2 = first virtual address
---
> 	ldr 	x2, =(VA_START + PHYS_MEMORY_SIZE)				// x2 = first virtual address
204a237,258
> 
> 	
> 	// sub x0, pg_dir
> 	// ldr x1, =(VA_START+PHYS_MEMORY_SIZE)
> 	// create_table_entry1 x0,x1,PMD_SHIFT, x2, x3
> 	// // mov x6, x0
> 
> 	/* Mapping physical memory. Phys addr range: DEVICE_BASE--PHYS_MEMORY_SIZE(0x40000000) */
> 	mov 	x1, #PHYS_MEMORY_SIZE									// x1 = start mapping from device base address 
> 	ldr 	x2, =(VA_START + PHYS_MEMORY_SIZE)						// x2 = first virtual address
> 	ldr		x3, =(VA_START + PHYS_MEMORY_SIZE + SECTION_SIZE)	// x3 = the virtual base of the last section
> 
> 	adrp x0, pg_dir
> 	add x0, x0, #PAGE_SIZE
> 	mov x6, x0
> 	add x0, x0, #PAGE_SIZE
> 	add x0, x0, #PAGE_SIZE
> 	// ldr x7, =(VA_START+PHYS_MEMORY_SIZE)
> 	create_table_entry1 x6,x2,PUD_SHIFT, x7, x8
> 
> 	create_block_map x0, x1, x2, x3, MMU_DEVICE_FLAGS, x4
> 
205a260
> 	// ldr   x30, [sp, #16*16]
diff -r --new-file exp6-copy/src/irq.c exp6/src/irq.c
31c31
< 	put32(ENABLE_IRQS_1, SYSTEM_TIMER_IRQ_1);
---
> 	// put32(ENABLE_IRQS_1, SYSTEM_TIMER_IRQ_1);
34c34
< //  put32(TIMER_INT_CTRL_0, TIMER_INT_CTRL_0_VALUE);
---
>  put32(TIMER_INT_CTRL_0, TIMER_INT_CTRL_0_VALUE);
42c42
< #if 0
---
> 
48c48
< 				handle_generic_timer_irq();
---
> 				handle_timer_irq();
54d53
< #endif
56,66c55,68
< void handle_irq(void)
< {
< 	unsigned int irq = get32(IRQ_PENDING_1);
< 	switch (irq) {
< 		case (SYSTEM_TIMER_IRQ_1):
< 			handle_timer_irq();
< 			break;
< 		default:
< 			printf("Inknown pending irq: %x\r\n", irq);
< 	}
< }
---
> 
> // void handle_irq(void)
> // {
> // 	printf("kl\t");
> // 	// handle_timer_irq(); 
> // 	unsigned int irq = get32(IRQ_PENDING_1);
> // 	switch (irq) {
> // 		case (SYSTEM_TIMER_IRQ_1):
> // 			handle_timer_irq();
> // 			break;
> // 		default:
> // 			printf("Inknown pending irq: %x\r\n", irq);
> // 	}
> // }
diff -r --new-file exp6-copy/src/kernel.c exp6/src/kernel.c
35,36c35,36
< 	timer_init();
< //	generic_timer_init();
---
> 	// timer_init();
> 	generic_timer_init();
diff -r --new-file exp6-copy/src/sched.c exp6/src/sched.c
75a76
> 	printf("rimetricm");
diff -r --new-file exp6-copy/src/timer.c exp6/src/timer.c
4a5,6
> #include "peripherals/irq.h"
> #include "timer.h"
6c8
< const unsigned int interval = 200000;
---
> const unsigned int interval = 20000;
18c20,39
< void timer_init ( void )
---
> // void timer_init ( void )
> // {
> // 	curVal = get32(TIMER_CLO);
> // 	curVal += interval;
> // 	put32(TIMER_C1, curVal);
> // }
> 
> // void handle_timer_irq( void ) 
> // {
> // 	curVal += interval;
> // 	put32(TIMER_C1, curVal);
> // 	put32(TIMER_CS, TIMER_CS_M1);
> // 	timer_tick();
> // }
> 
> /* 	These are for Arm generic timer. 
> 	They are fully functional on both QEMU and Rpi3 
> */
> 
> void generic_timer_init ( void )
20,22c41,43
< 	curVal = get32(TIMER_CLO);
< 	curVal += interval;
< 	put32(TIMER_C1, curVal);
---
> 	gen_timer_init();
> 	gen_timer_reset();
> 	put32(TIMER_INT_CTRL_0, TIMER_INT_CTRL_0_VALUE);
25c46
< void handle_timer_irq( void ) 
---
> void handle_timer_irq( void )
27,29c48,49
< 	curVal += interval;
< 	put32(TIMER_C1, curVal);
< 	put32(TIMER_CS, TIMER_CS_M1);
---
> 	printf("handle");
> 	gen_timer_reset();
32,47d51
< 
< /* 	These are for Arm generic timer. 
< 	They are fully functional on both QEMU and Rpi3 
< */
< 
< //void generic_timer_init ( void )
< //{
< //	gen_timer_init();
< //	gen_timer_reset();
< //}
< //
< //void handle_generic_timer_irq( void )
< //{
< //	gen_timer_reset();
< //	timer_tick();
< //}
